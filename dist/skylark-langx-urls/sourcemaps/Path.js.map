{"version":3,"sources":["Path.js"],"names":["define","types","klass","urls","Path","_construct","_","this","segments","hasLeading","hasTrailing","arguments","length","langx","isString","_parse","isArray","_canonicalize","doIt","i","stack","push","pop","_length","anotherPath","path","split","charAt","shift","append","tail","appendPathStr","appendPath","isAbsolute","mySegments","tailSegments","newSegments","concat","clone","endsWith","equals","another","anotherSegments","firstSegment","getExtension","extension","textension","substr","lastIndexOf","getSegments","getParentPath","parentPath","parentSegments","getRoot","lastSegment","matchingFirstSegments","pathSegments","max","Math","min","count","normalize","removeFirstSegments","slice","removeLastSegments","removeMatchingFirstSegments","match","removeMatchingLastSegments","removeRelative","segs","relativeTo","base","ignoreFilename","baseSegments","commonLength","baseSegmentLength","differenceLength","EMPTY","segment","index","startsWith","toString","result","join","get"],"mappings":"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","file":"../Path.js","sourcesContent":["define([\r\n    \"skylark-langx-types\",\r\n    \"skylark-langx-constructs/klass\",\r\n    \"./urls\"\r\n], function(types,klass,urls) {\r\n\r\n    /**\r\n     * @class Path\r\n     * @constructor\r\n     */\r\n    var Path =   klass({\r\n        _construct : function() {\r\n            var _ = this._ = {\r\n                segments : null,\r\n                hasLeading : false,\r\n                hasTrailing : false\r\n            };\r\n            if (arguments.length == 1 && langx.isString(arguments[0])) {\r\n                  this._parse(arguments[0]);\r\n            } else  if (langx.isArray(arguments[0])){\r\n                _.segments = arguments[0];\r\n                _.hasLeading = arguments[1] || false;\r\n                _.hasTrailing = arguments[2] || false;\r\n                this._canonicalize();                \r\n            }\r\n        },\r\n\r\n        _canonicalize: function() {\r\n            var doIt;\r\n            var segments = this._.segments;\r\n            for (var i = 0; i < segments.length; i++) {\r\n                if (segments[i] == \".\" || segments[i] == \"..\") {\r\n                    doIt = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (doIt) {\r\n                var stack = [];\r\n                for (var i = 0; i < segments.length; i++) {\r\n                    if (segments[i] == \"..\") {\r\n                        if (stack.length == 0) {\r\n                            // if the stack is empty we are going out of our scope\r\n                            // so we need to accumulate segments.  But only if the original\r\n                            // path is relative.  If it is absolute then we can't go any higher than\r\n                            // root so simply toss the .. references.\r\n                            if (!this.hasLeading) {\r\n                                stack.push(segments[i]); //stack push\r\n                            }\r\n                        } else {\r\n                            // if the top is '..' then we are accumulating segments so don't pop\r\n                            if (\"..\" == stack[stack.length - 1]) {\r\n                                stack.push(\"..\");\r\n                            } else {\r\n                                stack.pop();\r\n                            }\r\n                        }\r\n                        //collapse current references\r\n                    } else if (segments[i] != \".\" || segments.length == 1) {\r\n                        stack.push(segments[i]); //stack push\r\n                    }\r\n                }\r\n                //if the number of segments hasn't changed, then no modification needed\r\n                if (stack.length == segments.length) {\r\n                    return;\r\n                }\r\n                this._.segments = stack;\r\n            }\r\n        },\r\n\r\n        _length: function(anotherPath) {\r\n            return this._.segments.length;\r\n        },\r\n\r\n\r\n        _parse : function( /*String*/ path) {\r\n            if (!path) {\r\n                path = \".\";\r\n            }\r\n            var _ = this._,\r\n                segments = path.split(\"/\");\r\n\r\n            if (path.charAt(0) == \"/\") {\r\n                _.hasLeading = true;\r\n                segments.shift();\r\n            }\r\n            if (path.charAt(path.length - 1) == \"/\") {\r\n                _.hasTrailing = true;\r\n                // If the path ends in '/', split() will create an array whose last element\r\n                // is an empty string. Remove that here.\r\n                segments.pop();\r\n            }\r\n            _.segments = segments;\r\n            _.path = path;\r\n\r\n            this._canonicalize()\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method append\r\n         *@parameter {Path|String}tail\r\n         *@return {Path}\r\n         */\r\n        append: /*Path*/ function( /*Path*/ tail) {\r\n            if (types.isString(tail)) {\r\n                return this.appendPathStr(tail);\r\n            } else {\r\n                return this.appendPath(tail);\r\n            }\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method appendPath\r\n         *@parameter {Path}tail\r\n         *@return {Path}\r\n         */\r\n        appendPath: /*Path*/ function( /*Path*/ tail) {\r\n            if (tail.isAbsolute()) {\r\n                return tail;\r\n            }\r\n            var mySegments = this.segments,\r\n                tailSegments = tail.segments,\r\n                newSegments = mySegments.concat(tailSegments),\r\n                result = new Path(newSegments, this.hasLeading, tail.hasTrailing);\r\n            return result;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method appendPathStr\r\n         *@parameter {String}tail\r\n         *@return {Path}\r\n         */\r\n        appendPathStr: function( /*String*/ tail) {\r\n            tail = new Path(tail || \"\");\r\n            return this.appendPath(tail);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method clone\r\n         *@return {Path}\r\n         */\r\n        \"clone\": function() {\r\n            return new Path(this.segments, this.hasLeading, this.hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *Tests if this path ends with the given path.\r\n         *@method endsWidth\r\n         *@parameter {String}tail\r\n         *@return {Boolean}\r\n         */\r\n        \"endsWith\": /*Boolean*/ function( /*String*/ tail) {\r\n            var segments = this.segments;\r\n            var tailSegments = (new Path(tail)).segments;\r\n            while (tailSegments.length > 0 && segments.length > 0) {\r\n                if (tailSegments.pop() != segments.pop()) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        },\r\n\r\n        /*\r\n         *Tests this path for equality with the given object.\r\n         *@method equals\r\n         *@parameter {Path}another\r\n         *@return {Boolean}\r\n         */\r\n        \"equals\": /*Boolean*/ function( /*Path*/ another) {\r\n            var segments = this._.segments,\r\n                anotherSegments = another._.segments;\r\n            if (segments.length != anotherSegments.length) {\r\n                return false;\r\n            }\r\n            for (var i = 0; i < segments.length; i++) {\r\n                if (anotherSegments[i] != segments[i]) {\r\n                    return false;\r\n                };\r\n            }\r\n            return true;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method firstSegment\r\n         *@parameter {Number}length\r\n         *@return {String}\r\n         */\r\n        firstSegment: /*String*/ function( /*Number*/ length) {\r\n            var segments = this._.segments;\r\n            return segments[length || 0];\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method getExtension\r\n         *@return {String}\r\n         */\r\n        getExtension: function() {\r\n            var extension = this._.extension,\r\n                path = this._.path;\r\n            if (!textension) {\r\n                extension = this._.extension = path.substr(path.lastIndexOf('.') + 1);\r\n            }\r\n            return extension;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method getSegments\r\n         *@return {Array}\r\n         */\r\n        getSegments: /*Array*/ function() {\r\n            return this.segments;\r\n        },\r\n\r\n        /*\r\n         *Returns the parent path, or null if this path does not have a parent.\r\n         *@method getParentPath\r\n         *@return {Path}\r\n         */\r\n        getParentPath: /*Path*/ function() {\r\n            var parentPath = this._.parentPath;\r\n            if (!parentPath) {\r\n                var parentSegments = this.segments;\r\n                parentSegments.pop();\r\n                parentPath = this._.parentPath = new Path(parentSegments, this.hasLeading);\r\n            }\r\n            return parentPath;\r\n        },\r\n\r\n\r\n        /*\r\n         *Returns the root component of this path as a Path object, or null if this path does not have a root component.\r\n         *@method getRoot\r\n         *@return {Path}\r\n         */\r\n        \"getRoot\": /*Path*/ function() {\r\n            //TODO: will be implemented\r\n        },\r\n\r\n        /*\r\n         *Tells whether or not this path is absolute.\r\n         *@method isAbsolute\r\n         *@return {Boolean}\r\n         */\r\n        isAbsolute: /*Boolean*/ function() {\r\n            return this.hasLeading;\r\n        },\r\n\r\n\r\n        /*\r\n         *\r\n         *@method lastSegment\r\n         *@ return {String}\r\n         */\r\n        lastSegment: /*String*/ function() {\r\n            var segments = this._.segments;\r\n            return segments[segments.length - 1];\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method matchingFirstSegments\r\n         *@parameter {Path}another\r\n         *@return {Number}\r\n         */\r\n        matchingFirstSegments: /*Number*/ function( /*Path*/ another) {\r\n            var mySegments = this.segments;\r\n            var pathSegments = another.segments;\r\n            var max = Math.min(mySegments.length, pathSegments.length);\r\n            var count = 0;\r\n            for (var i = 0; i < max; i++) {\r\n                if (mySegments[i] != pathSegments[i]) {\r\n                    return count;\r\n                }\r\n                count++;\r\n            }\r\n            return count;\r\n        },\r\n\r\n        /*\r\n         *Returns a path that is this path with redundant name elements eliminated.\r\n         *@method normalize\r\n         *@return {Path}\r\n         */\r\n        \"normalize\": /*Path*/ function() {\r\n            //TODO: will be implemented\r\n        },\r\n\r\n\r\n        /*\r\n         *\r\n         *@method removeFirstSegments\r\n         *@parameter {Number}count\r\n         *@return {Path}\r\n         */\r\n        removeFirstSegments: /*Path*/ function( /*Number*/ count) {\r\n            var segments = this._.segments,\r\n                hasLeading = this._.hasLeading;\r\n            hasTrailing = this._.hasTrailing;\r\n\r\n            return new Path(segments.slice(count, segments.length), hasLeading, hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeLastSegments\r\n         *@parameter {Number}count\r\n         *@return {Path}\r\n         */\r\n        removeLastSegments: /*Path*/ function( /*Number?*/ count) {\r\n            var segments = this._.segments,\r\n                hasLeading = this._.hasLeading;\r\n            hasTrailing = this._.hasTrailing;\r\n\r\n            if (!count) {\r\n                count = 1;\r\n            }\r\n\r\n            return new Path(segments.slice(0, segments.length - count), hasLeading, hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeMatchingFirstSegments\r\n         *@parameter {Path}another\r\n         *@return {Path}\r\n         */\r\n        removeMatchingFirstSegments: /*Path*/ function( /*Path*/ another) {\r\n            var match = this.matchingFirstSegments(another);\r\n            return this.removeFirstSegments(match);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeMatchingLastSegments\r\n         *@parameter {Path}another\r\n         *@return {Path}\r\n         */\r\n        removeMatchingLastSegments: /*Path*/ function( /*Path*/ another) {\r\n            var match = this.matchingFirstSegments(anotherPath);\r\n            return this.removeLastSegments(match);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeRelative\r\n         *@return {Path}\r\n         */\r\n        removeRelative: function() {\r\n            var segs = this.segments;\r\n            if (segs.length > 0 && segs[1] == \".\")\r\n                return this.removeFirstSegments(1);\r\n            return this;\r\n        },\r\n\r\n        /*\r\n         *Constructs a relative path between this path and a given path.\r\n         *@method relativeTo\r\n         *@parameter {Path}base\r\n         *@return {Path}\r\n         */\r\n        relativeTo: /*Path*/ function( /*Path|String*/ base, /*Boolean*/ ignoreFilename) {\r\n            if (typeof base == 'string') {\r\n                base = new Path(base);\r\n            }\r\n            var mySegments = this.segments;\r\n            if (this.isAbsolute()) {\r\n                return this;\r\n            }\r\n            var baseSegments = base.segments;\r\n            var commonLength = this.matchingFirstSegments(base);\r\n            var baseSegmentLength = baseSegments.length;\r\n            if (ignoreFilename) {\r\n                baseSegmentLength = baseSegmentLength - 1;\r\n            }\r\n            var differenceLength = baseSegmentLength - commonLength;\r\n            var newSegmentLength = differenceLength + mySegments.length - commonLength;\r\n            if (newSegmentLength == 0) {\r\n                return Path.EMPTY;\r\n            }\r\n            var newSegments = [];\r\n            for (var i = 0; i < differenceLength; i++) {\r\n                newSegments.push('..');\r\n            }\r\n            for (var i = commonLength; i < mySegments.length; i++) {\r\n                newSegments.push(mySegments[i]);\r\n            }\r\n            return new Path(newSegments, false, this.hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method segment\r\n         *@parameter {Number}index\r\n         *@return {String}\r\n         */\r\n        segment: /*String*/ function( /*Number*/ index) {\r\n            var segments = this._.segments;\r\n            if (segments.length < index) return null;\r\n            return segments[index];\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method startsWith\r\n         *@parameter {Path}index\r\n         *@return {Boolean}\r\n         */\r\n        startsWith: /*Boolean*/ function( /*Path*/ another) {\r\n            var count = this.matchingFirstSegments(another);\r\n            return another._length() == count;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method toString\r\n         *@return {String}\r\n         */\r\n        toString: function() {\r\n            var result = [],\r\n                segments = this._.segments;\r\n            if (this.hasLeading) {\r\n                result.push(\"/\");\r\n            }\r\n            for (var i = 0; i < segments.length; i++) {\r\n                if (i > 0) {\r\n                    result.push(\"/\");\r\n                }\r\n                result.push(segments[i]);\r\n            }\r\n            if (this.hasTrailing) {\r\n                result.push(\"/\");\r\n            }\r\n            return result.join(\"\");\r\n        },\r\n\r\n        hasLeading : {\r\n            get : function() {\r\n                return this._.hasLeading\r\n            }\r\n        },\r\n\r\n        hasTrailing : {\r\n            get : function() {\r\n                return this._.hasTrailing\r\n            }\r\n        }\r\n\r\n    });\r\n\r\n\r\n    Path.EMPTY = new Path(\"\");\r\n\r\n    return urls.Path = Path;\r\n});\r\n"]}