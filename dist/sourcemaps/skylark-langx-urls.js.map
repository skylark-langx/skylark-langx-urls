{"version":3,"sources":["skylark-langx-urls.js"],"names":["define","skylark","attach","urls","digits","createObjectURL","data","contentType","forceDataSchema","URL","blob","Blob","type","buffer","i","ii","length","b1","b2","b3","d1","d2","d3","d4","getAbsoluteUrl","url","match","div","document","createElement","innerHTML","firstChild","href","getFileExtension","path","splitPathRe","pathParts","exec","pop","toLowerCase","getFileName","anchor","indexOf","query","end","Math","min","substring","lastIndexOf","getQuery","querystring","pairs","split","keyval","decodeURIComponent","e","undefined","parseUrl","props","a","addToBody","host","protocol","setAttribute","body","appendChild","details","replace","window","location","removeChild","isCrossOrigin","winLoc","urlInfo","types","klass","Path","_construct","_","this","segments","hasLeading","hasTrailing","arguments","isString","_parse","isArray","_canonicalize","doIt","stack","push","_length","anotherPath","charAt","shift","append","tail","appendPathStr","appendPath","isAbsolute","mySegments","tailSegments","newSegments","concat","result","clone","endsWith","equals","another","anotherSegments","firstSegment","getExtension","extension","textension","substr","getSegments","getParentPath","parentPath","parentSegments","getRoot","lastSegment","matchingFirstSegments","pathSegments","max","count","normalize","removeFirstSegments","slice","removeLastSegments","removeMatchingFirstSegments","removeMatchingLastSegments","removeRelative","segs","relativeTo","base","ignoreFilename","baseSegments","commonLength","baseSegmentLength","differenceLength","newSegmentLength","EMPTY","segment","index","startsWith","toString","join","get","main"],"mappings":"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","file":"../skylark-langx-urls.js","sourcesContent":["define('skylark-langx-urls/urls',[\r\n  \"skylark-langx-ns\"\r\n],function(skylark){\r\n\r\n\r\n    return skylark.attach(\"langx.urls\",{\r\n\r\n    });\r\n});\r\n\r\n\r\n\ndefine('skylark-langx-urls/create_object_url',[\r\n    './urls'\r\n], function (urls) {\r\n    'use strict';\r\n\r\n    const digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\n    function createObjectURL(data, contentType, forceDataSchema = false) {\r\n        if (!forceDataSchema && URL.createObjectURL) {\r\n            const blob = new Blob([data], { type: contentType });\r\n            return URL.createObjectURL(blob);\r\n        }\r\n        let buffer = `data:${ contentType };base64,`;\r\n        for (let i = 0, ii = data.length; i < ii; i += 3) {\r\n            const b1 = data[i] & 255;\r\n            const b2 = data[i + 1] & 255;\r\n            const b3 = data[i + 2] & 255;\r\n            const d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;\r\n            const d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;\r\n            const d4 = i + 2 < ii ? b3 & 63 : 64;\r\n            buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\r\n        }\r\n        return buffer;\r\n    };\r\n\r\n\r\n    return urls.createObjectURL = createObjectURL;\r\n\r\n});\r\n\r\n\ndefine('skylark-langx-urls/get-absolute-url',[\r\n    './urls'\r\n], function (urls) {\r\n    'use strict';\r\n\r\n    const getAbsoluteUrl = function (url) {\r\n        if (!url.match(/^https?:\\/\\//)) {\r\n            const div = document.createElement('div');\r\n            div.innerHTML = `<a href=\"${ url }\">x</a>`;\r\n            url = div.firstChild.href;\r\n        }\r\n        return url;\r\n    };\r\n\r\n    return urls.getAbsoluteUrl = getAbsoluteUrl;\r\n\r\n});\ndefine('skylark-langx-urls/get-file-extension',[\r\n    './urls'\r\n], function (urls) {\r\n    'use strict';\r\n\r\n    const getFileExtension = function (path) {\r\n        if (typeof path === 'string') {\r\n            const splitPathRe = /^(\\/?)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?)(\\.([^\\.\\/\\?]+)))(?:[\\/]*|[\\?].*)$/;\r\n            const pathParts = splitPathRe.exec(path);\r\n            if (pathParts) {\r\n                return pathParts.pop().toLowerCase();\r\n            }\r\n        }\r\n        return '';\r\n    };\r\n\r\n    return urls.getFileExtension = getFileExtension;\r\n\r\n});\n   define('skylark-langx-urls/get-file-name',[\r\n    './urls'\r\n], function (urls) {\r\n    'use strict';\r\n\r\n    function getFileName (url) {\r\n        ///var fileName = url.split('/').pop() || \"\";\r\n        ///return fileName;\r\n        const anchor = url.indexOf('#');\r\n        const query = url.indexOf('?');\r\n        const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);\r\n        return url.substring(url.lastIndexOf('/', end) + 1, end);         \r\n    }\r\n\r\n\r\n\r\n\r\n    return urls.getFileName = getFileName;\r\n\r\n});\ndefine('skylark-langx-urls/get-query',[\r\n    './urls'\r\n], function (urls) {\r\n    'use strict';\r\n\tfunction getQuery(querystring) {\r\n\t\tvar query = {};\r\n\r\n\t\tvar pairs = querystring.split('&'),\r\n\t\t    length = pairs.length,\r\n\t\t    keyval = [],\r\n\t\t    i = 0;\r\n\r\n\t\tfor (; i < length; i++) {\r\n\t\t  keyval = pairs[i].split('=', 2);\r\n\t\t  try {\r\n\t\t    keyval[0] = decodeURIComponent(keyval[0]); // key\r\n\t\t    keyval[1] = decodeURIComponent(keyval[1]); // value\r\n\t\t  } catch (e) {}\r\n\r\n\t\t  if (query[keyval[0]] === undefined) {\r\n\t\t    query[keyval[0]] = keyval[1];\r\n\t\t  } else {\r\n\t\t    query[keyval[0]] += ',' + keyval[1];\r\n\t\t  }\r\n\t\t}\r\n\r\n\t\treturn query;\r\n\t}\r\n\r\n\treturn urls.getQuery = getQuery;\r\n\r\n});\ndefine('skylark-langx-urls/parse-url',[\r\n    './urls'\r\n], function (urls) {\r\n    'use strict';\r\n    const parseUrl = function (url) {\r\n        const props = [\r\n            'protocol',\r\n            'hostname',\r\n            'port',\r\n            'pathname',\r\n            'search',\r\n            'hash',\r\n            'host'\r\n        ];\r\n        let a = document.createElement('a');\r\n        a.href = url;\r\n        const addToBody = a.host === '' && a.protocol !== 'file:';\r\n        let div;\r\n        if (addToBody) {\r\n            div = document.createElement('div');\r\n            div.innerHTML = `<a href=\"${ url }\"></a>`;\r\n            a = div.firstChild;\r\n            div.setAttribute('style', 'display:none; position:absolute;');\r\n            document.body.appendChild(div);\r\n        }\r\n        const details = {};\r\n        for (let i = 0; i < props.length; i++) {\r\n            details[props[i]] = a[props[i]];\r\n        }\r\n        if (details.protocol === 'http:') {\r\n            details.host = details.host.replace(/:80$/, '');\r\n        }\r\n        if (details.protocol === 'https:') {\r\n            details.host = details.host.replace(/:443$/, '');\r\n        }\r\n        if (!details.protocol) {\r\n            details.protocol = window.location.protocol;\r\n        }\r\n        if (addToBody) {\r\n            document.body.removeChild(div);\r\n        }\r\n        return details;\r\n    };\r\n\r\n    return urls.parseUrl = parseUrl;\r\n});\ndefine('skylark-langx-urls/is-cross-origin',[\r\n    './urls',\r\n    \"./parse-url\"\r\n], function (urls,parseUrl) {\r\n    'use strict';\r\n\r\n    const isCrossOrigin = function (url, winLoc = window.location) {\r\n        const urlInfo = parseUrl(url);\r\n        const srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;\r\n        const crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;\r\n        return crossOrigin;\r\n    };\r\n\r\n    return urls.isCrossOrigin = isCrossOrigin;\r\n\r\n});\ndefine('skylark-langx-urls/path',[\r\n    \"skylark-langx-types\",\r\n    \"skylark-langx-constructs/klass\",\r\n    \"./urls\"\r\n], function(types,klass,urls) {\r\n\r\n    /**\r\n     * @class Path\r\n     * @constructor\r\n     */\r\n    var Path =   klass({\r\n        _construct : function() {\r\n            var _ = this._ = {\r\n                segments : null,\r\n                hasLeading : false,\r\n                hasTrailing : false\r\n            };\r\n            if (arguments.length == 1 && types.isString(arguments[0])) {\r\n                  this._parse(arguments[0]);\r\n            } else  if (types.isArray(arguments[0])){\r\n                _.segments = arguments[0];\r\n                _.hasLeading = arguments[1] || false;\r\n                _.hasTrailing = arguments[2] || false;\r\n                this._canonicalize();                \r\n            }\r\n        },\r\n\r\n        _canonicalize: function() {\r\n            var doIt;\r\n            var segments = this._.segments;\r\n            for (var i = 0; i < segments.length; i++) {\r\n                if (segments[i] == \".\" || segments[i] == \"..\") {\r\n                    doIt = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (doIt) {\r\n                var stack = [];\r\n                for (var i = 0; i < segments.length; i++) {\r\n                    if (segments[i] == \"..\") {\r\n                        if (stack.length == 0) {\r\n                            // if the stack is empty we are going out of our scope\r\n                            // so we need to accumulate segments.  But only if the original\r\n                            // path is relative.  If it is absolute then we can't go any higher than\r\n                            // root so simply toss the .. references.\r\n                            if (!this.hasLeading) {\r\n                                stack.push(segments[i]); //stack push\r\n                            }\r\n                        } else {\r\n                            // if the top is '..' then we are accumulating segments so don't pop\r\n                            if (\"..\" == stack[stack.length - 1]) {\r\n                                stack.push(\"..\");\r\n                            } else {\r\n                                stack.pop();\r\n                            }\r\n                        }\r\n                        //collapse current references\r\n                    } else if (segments[i] != \".\" || segments.length == 1) {\r\n                        stack.push(segments[i]); //stack push\r\n                    }\r\n                }\r\n                //if the number of segments hasn't changed, then no modification needed\r\n                if (stack.length == segments.length) {\r\n                    return;\r\n                }\r\n                this._.segments = stack;\r\n            }\r\n        },\r\n\r\n        _length: function(anotherPath) {\r\n            return this._.segments.length;\r\n        },\r\n\r\n\r\n        _parse : function( /*String*/ path) {\r\n            if (!path) {\r\n                path = \".\";\r\n            }\r\n            var _ = this._,\r\n                segments = path.split(\"/\");\r\n\r\n            if (path.charAt(0) == \"/\") {\r\n                _.hasLeading = true;\r\n                segments.shift();\r\n            }\r\n            if (path.charAt(path.length - 1) == \"/\") {\r\n                _.hasTrailing = true;\r\n                // If the path ends in '/', split() will create an array whose last element\r\n                // is an empty string. Remove that here.\r\n                segments.pop();\r\n            }\r\n            _.segments = segments;\r\n            _.path = path;\r\n\r\n            this._canonicalize()\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method append\r\n         *@parameter {Path|String}tail\r\n         *@return {Path}\r\n         */\r\n        append: /*Path*/ function( /*Path*/ tail) {\r\n            if (types.isString(tail)) {\r\n                return this.appendPathStr(tail);\r\n            } else {\r\n                return this.appendPath(tail);\r\n            }\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method appendPath\r\n         *@parameter {Path}tail\r\n         *@return {Path}\r\n         */\r\n        appendPath: /*Path*/ function( /*Path*/ tail) {\r\n            if (tail.isAbsolute()) {\r\n                return tail;\r\n            }\r\n            var mySegments = this.segments,\r\n                tailSegments = tail.segments,\r\n                newSegments = mySegments.concat(tailSegments),\r\n                result = new Path(newSegments, this.hasLeading, tail.hasTrailing);\r\n            return result;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method appendPathStr\r\n         *@parameter {String}tail\r\n         *@return {Path}\r\n         */\r\n        appendPathStr: function( /*String*/ tail) {\r\n            tail = new Path(tail || \"\");\r\n            return this.appendPath(tail);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method clone\r\n         *@return {Path}\r\n         */\r\n        \"clone\": function() {\r\n            return new Path(this.segments, this.hasLeading, this.hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *Tests if this path ends with the given path.\r\n         *@method endsWidth\r\n         *@parameter {String}tail\r\n         *@return {Boolean}\r\n         */\r\n        \"endsWith\": /*Boolean*/ function( /*String*/ tail) {\r\n            var segments = this.segments;\r\n            var tailSegments = (new Path(tail)).segments;\r\n            while (tailSegments.length > 0 && segments.length > 0) {\r\n                if (tailSegments.pop() != segments.pop()) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        },\r\n\r\n        /*\r\n         *Tests this path for equality with the given object.\r\n         *@method equals\r\n         *@parameter {Path}another\r\n         *@return {Boolean}\r\n         */\r\n        \"equals\": /*Boolean*/ function( /*Path*/ another) {\r\n            var segments = this._.segments,\r\n                anotherSegments = another._.segments;\r\n            if (segments.length != anotherSegments.length) {\r\n                return false;\r\n            }\r\n            for (var i = 0; i < segments.length; i++) {\r\n                if (anotherSegments[i] != segments[i]) {\r\n                    return false;\r\n                };\r\n            }\r\n            return true;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method firstSegment\r\n         *@parameter {Number}length\r\n         *@return {String}\r\n         */\r\n        firstSegment: /*String*/ function( /*Number*/ length) {\r\n            var segments = this._.segments;\r\n            return segments[length || 0];\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method getExtension\r\n         *@return {String}\r\n         */\r\n        getExtension: function() {\r\n            var extension = this._.extension,\r\n                path = this._.path;\r\n            if (!textension) {\r\n                extension = this._.extension = path.substr(path.lastIndexOf('.') + 1);\r\n            }\r\n            return extension;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method getSegments\r\n         *@return {Array}\r\n         */\r\n        getSegments: /*Array*/ function() {\r\n            return this.segments;\r\n        },\r\n\r\n        /*\r\n         *Returns the parent path, or null if this path does not have a parent.\r\n         *@method getParentPath\r\n         *@return {Path}\r\n         */\r\n        getParentPath: /*Path*/ function() {\r\n            var parentPath = this._.parentPath;\r\n            if (!parentPath) {\r\n                var parentSegments = this.segments;\r\n                parentSegments.pop();\r\n                parentPath = this._.parentPath = new Path(parentSegments, this.hasLeading);\r\n            }\r\n            return parentPath;\r\n        },\r\n\r\n\r\n        /*\r\n         *Returns the root component of this path as a Path object, or null if this path does not have a root component.\r\n         *@method getRoot\r\n         *@return {Path}\r\n         */\r\n        \"getRoot\": /*Path*/ function() {\r\n            //TODO: will be implemented\r\n        },\r\n\r\n        /*\r\n         *Tells whether or not this path is absolute.\r\n         *@method isAbsolute\r\n         *@return {Boolean}\r\n         */\r\n        isAbsolute: /*Boolean*/ function() {\r\n            return this.hasLeading;\r\n        },\r\n\r\n\r\n        /*\r\n         *\r\n         *@method lastSegment\r\n         *@ return {String}\r\n         */\r\n        lastSegment: /*String*/ function() {\r\n            var segments = this._.segments;\r\n            return segments[segments.length - 1];\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method matchingFirstSegments\r\n         *@parameter {Path}another\r\n         *@return {Number}\r\n         */\r\n        matchingFirstSegments: /*Number*/ function( /*Path*/ another) {\r\n            var mySegments = this.segments;\r\n            var pathSegments = another.segments;\r\n            var max = Math.min(mySegments.length, pathSegments.length);\r\n            var count = 0;\r\n            for (var i = 0; i < max; i++) {\r\n                if (mySegments[i] != pathSegments[i]) {\r\n                    return count;\r\n                }\r\n                count++;\r\n            }\r\n            return count;\r\n        },\r\n\r\n        /*\r\n         *Returns a path that is this path with redundant name elements eliminated.\r\n         *@method normalize\r\n         *@return {Path}\r\n         */\r\n        \"normalize\": /*Path*/ function() {\r\n            //TODO: will be implemented\r\n        },\r\n\r\n\r\n        /*\r\n         *\r\n         *@method removeFirstSegments\r\n         *@parameter {Number}count\r\n         *@return {Path}\r\n         */\r\n        removeFirstSegments: /*Path*/ function( /*Number*/ count) {\r\n            var segments = this._.segments,\r\n                hasLeading = this._.hasLeading;\r\n            hasTrailing = this._.hasTrailing;\r\n\r\n            return new Path(segments.slice(count, segments.length), hasLeading, hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeLastSegments\r\n         *@parameter {Number}count\r\n         *@return {Path}\r\n         */\r\n        removeLastSegments: /*Path*/ function( /*Number?*/ count) {\r\n            var segments = this._.segments,\r\n                hasLeading = this._.hasLeading;\r\n            hasTrailing = this._.hasTrailing;\r\n\r\n            if (!count) {\r\n                count = 1;\r\n            }\r\n\r\n            return new Path(segments.slice(0, segments.length - count), hasLeading, hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeMatchingFirstSegments\r\n         *@parameter {Path}another\r\n         *@return {Path}\r\n         */\r\n        removeMatchingFirstSegments: /*Path*/ function( /*Path*/ another) {\r\n            var match = this.matchingFirstSegments(another);\r\n            return this.removeFirstSegments(match);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeMatchingLastSegments\r\n         *@parameter {Path}another\r\n         *@return {Path}\r\n         */\r\n        removeMatchingLastSegments: /*Path*/ function( /*Path*/ another) {\r\n            var match = this.matchingFirstSegments(anotherPath);\r\n            return this.removeLastSegments(match);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeRelative\r\n         *@return {Path}\r\n         */\r\n        removeRelative: function() {\r\n            var segs = this.segments;\r\n            if (segs.length > 0 && segs[1] == \".\")\r\n                return this.removeFirstSegments(1);\r\n            return this;\r\n        },\r\n\r\n        /*\r\n         *Constructs a relative path between this path and a given path.\r\n         *@method relativeTo\r\n         *@parameter {Path}base\r\n         *@return {Path}\r\n         */\r\n        relativeTo: /*Path*/ function( /*Path|String*/ base, /*Boolean*/ ignoreFilename) {\r\n            if (typeof base == 'string') {\r\n                base = new Path(base);\r\n            }\r\n            var mySegments = this.segments;\r\n            if (this.isAbsolute()) {\r\n                return this;\r\n            }\r\n            var baseSegments = base.segments;\r\n            var commonLength = this.matchingFirstSegments(base);\r\n            var baseSegmentLength = baseSegments.length;\r\n            if (ignoreFilename) {\r\n                baseSegmentLength = baseSegmentLength - 1;\r\n            }\r\n            var differenceLength = baseSegmentLength - commonLength;\r\n            var newSegmentLength = differenceLength + mySegments.length - commonLength;\r\n            if (newSegmentLength == 0) {\r\n                return Path.EMPTY;\r\n            }\r\n            var newSegments = [];\r\n            for (var i = 0; i < differenceLength; i++) {\r\n                newSegments.push('..');\r\n            }\r\n            for (var i = commonLength; i < mySegments.length; i++) {\r\n                newSegments.push(mySegments[i]);\r\n            }\r\n            return new Path(newSegments, false, this.hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method segment\r\n         *@parameter {Number}index\r\n         *@return {String}\r\n         */\r\n        segment: /*String*/ function( /*Number*/ index) {\r\n            var segments = this._.segments;\r\n            if (segments.length < index) return null;\r\n            return segments[index];\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method startsWith\r\n         *@parameter {Path}index\r\n         *@return {Boolean}\r\n         */\r\n        startsWith: /*Boolean*/ function( /*Path*/ another) {\r\n            var count = this.matchingFirstSegments(another);\r\n            return another._length() == count;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method toString\r\n         *@return {String}\r\n         */\r\n        toString: function() {\r\n            var result = [],\r\n                segments = this._.segments;\r\n            if (this.hasLeading) {\r\n                result.push(\"/\");\r\n            }\r\n            for (var i = 0; i < segments.length; i++) {\r\n                if (i > 0) {\r\n                    result.push(\"/\");\r\n                }\r\n                result.push(segments[i]);\r\n            }\r\n            if (this.hasTrailing) {\r\n                result.push(\"/\");\r\n            }\r\n            return result.join(\"\");\r\n        },\r\n\r\n        hasLeading : {\r\n            get : function() {\r\n                return this._.hasLeading\r\n            }\r\n        },\r\n\r\n        hasTrailing : {\r\n            get : function() {\r\n                return this._.hasTrailing\r\n            }\r\n        }\r\n\r\n    });\r\n\r\n\r\n    Path.EMPTY = new Path(\"\");\r\n\r\n    return urls.Path = Path;\r\n});\r\n\ndefine('skylark-langx-urls/main',[\r\n\t\"./urls\",\r\n\t\"./create_object_url\",\r\n\t\"./get-absolute-url\",\r\n\t\"./get-file-extension\",\r\n\t\"./get-file-name\",\r\n\t\"./get-query\",\r\n\t\"./is-cross-origin\",\r\n\t\"./parse-url\",\r\n\t\"./path\"\r\n],function(urls){\r\n\treturn urls;\r\n});\ndefine('skylark-langx-urls', ['skylark-langx-urls/main'], function (main) { return main; });\n\n"]}